diff --git a/drivers/media/platform/imx8/ar0521.c b/drivers/media/platform/imx8/ar0521.c
index ad0b1b973a7f..6bb0ad01db97 100644
--- a/drivers/media/platform/imx8/ar0521.c
+++ b/drivers/media/platform/imx8/ar0521.c
@@ -41,7 +41,7 @@ static int pwdn_gpio, reset_gpio;
 
 int gpios_available(void)
 {
-	return (pwdn_gpio >= 0) && (reset_gpio >= 0);
+	return true;
 }
 
 /**********************************************************************
@@ -3426,8 +3426,35 @@ static int ar0521_probe(struct i2c_client *client,
 	 * seem to be needed here as the Variscite EVK seems to be supplying
 	 * the required voltage directly without us needing to set it.
 	 */
-	toggle_gpio(reset_gpio, 1);
-	msleep(500);
+
+	int retval;
+	struct gpio_desc *csenable;
+
+	csenable = devm_gpiod_get_optional(dev, "csenable", GPIOD_OUT_HIGH);
+	if (IS_ERR(csenable)) {
+		retval = PTR_ERR(csenable);
+		dev_err(dev, "%s(): CANT FIND GPIO!\n", __func__);
+	} else {
+		dev_err(dev, "%s(): CSEnable pin OK!\n", __func__);
+	}
+
+	if (csenable) {
+		dev_err(dev, "%s(): CSEnable high!\n", __func__);
+		gpiod_set_value(csenable, 1);
+	} else {
+		dev_err(dev, "%s(): ERROR CSEnable!\n", __func__);
+	}
+
+	dev_info(dev, "Waiting for csi enable to stabilize!\n");
+
+	msleep(2000);
+
+	dev_info(dev, "Proceeding!!\n");
+
+	if (gpios_available()) {
+		toggle_gpio(reset_gpio, 1);
+		msleep(500);
+	}
 
 	ret = ar0521_verify_mcu(client);
 	if (ret) {
